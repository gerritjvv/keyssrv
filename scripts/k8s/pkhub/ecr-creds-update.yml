apiVersion: v1
kind: ServiceAccount
metadata:
  name: ecr-creds-update
  namespace: pkhub
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: pkhub
  name: ecr-creds-update-role
rules:
- apiGroups: [""] # "" indicates the core API group
  resources: ["secrets"]
  verbs: ["create", "update", "patch", "delete", "get"]
- apiGroups: [""] # "" indicates the core API group
  resources: ["serviceaccounts"]
  verbs: ["update", "patch", "get"]
---

kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: ecr-creds-update-role-binding
  namespace: pkhub
subjects:
- kind: ServiceAccount
  name: ecr-creds-update
  namespace: pkhub
roleRef:
  kind: Role
  name: ecr-creds-update-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1beta1
kind: CronJob  # Tell kuber' that this is a cronjob
metadata:
  annotations:
  name: ecr-cred-helper  # Name of the job ,can be anything
  namespace: pkhub

spec:
  concurrencyPolicy: Allow
  failedJobsHistoryLimit: 1
  jobTemplate:
    metadata:
      creationTimestamp: null
    spec:
      template:
        metadata:
          creationTimestamp: null
        spec:
          serviceAccountName: ecr-creds-update
          containers:    # the conatiner that will be triggerd by cronjob
          - image: odaniait/aws-kubectl:latest   # the base iamge to be used to run our shell script
            imagePullPolicy: IfNotPresent  # as per your requirement | standard | read docs
            name: ecr-cred-helper # as per your requirement | standard | read docs
            command:    # our script goes here
            - /bin/sh   # standard | set the entry point for execution after cron triggered
            - -c        # standard
            - |-        # actuall script starts + some stuff to execute pipe script when config is sent ot kuber'
              export REGION="us-east-1"
              export ACCOUNT=349236026960
              export SECRET_NAME=us-east-1-ecr-registry
              export EMAIL=admin@pkhub.io
              TOKEN=`aws ecr get-login --no-include-email --region us-east-1| cut -d' ' -f6`
              echo "ENV variables setup done."
              echo "DELETE: " kubectl delete secret --ignore-not-found $SECRET_NAME
              kubectl delete secret --ignore-not-found us-east-1-ecr-registry
              echo "CREATE: " kubectl create secret docker-registry us-east-1-ecr-registry --docker-server=https://$ACCOUNT}.dkr.ecr.${REGION}.amazonaws.com  --docker-username=AWS --docker-password="${TOKEN}" --docker-email="${EMAIL}"

              kubectl create secret docker-registry $SECRET_NAME --docker-server=https://${ACCOUNT}.dkr.ecr.${REGION}.amazonaws.com  --docker-username=AWS --docker-password="${TOKEN}" --docker-email="${EMAIL}"
              echo "Secret created by name. $SECRET_NAME"
              kubectl patch serviceaccount default -p '{"imagePullSecrets":[{"name":"'$SECRET_NAME'"}]}'
              echo "All done."

            env:
            - name: REGION
              valueFrom:
                secretKeyRef:
                  name: keyssrv
                  key: ECR_AWS_REGION
            - name: AWS_DEFAULT_REGION
              valueFrom:
                secretKeyRef:
                  name: keyssrv
                  key: ECR_AWS_REGION
            - name: AWS_SECRET_ACCESS_KEY
              valueFrom:
                  secretKeyRef:
                    name: keyssrv
                    key: ECR_AWS_SECRET_ACCESS_KEY
            - name: AWS_ACCESS_KEY_ID
              valueFrom:
                  secretKeyRef:
                    name: keyssrv
                    key: ECR_AWS_ACCESS_KEY_ID
            - name: ECR_ACCOUNT
              valueFrom:
                  secretKeyRef:
                    name: keyssrv
                    key: ECR_ACCOUNT
            resources: {}
            securityContext:
              capabilities: {}
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
          dnsPolicy: Default   # workload | custom | sometimes pod wont have intenet acces in 'clsuter first'
          hostNetwork: true
          restartPolicy: Never  # workload | standard | as per requirement
          schedulerName: default-scheduler # workload | standard | as per requirement
          securityContext: {}
          terminationGracePeriodSeconds: 30
  schedule: 0 */6 * * *  # workload | cron pattern | every 6 hours
  successfulJobsHistoryLimit: 3
  suspend: false